# Sample clean architecture app with Kotlin, MVVM, RxMVP, Rx, mappers generators, DI improvements, etc

## Why?

I implemented (with my work colleagues) Android application using concepts and tools like: 
clean architecture, dependency inversion, MVP, RxMVP, TDD, Rx, Realm, Mockito, caching/offline experience 
and we’ve learned a lot, a lot, a lot, a lot. 

But also we (IM(and not only mine)HO) wrote a lot of 
1. Boilerplate in every layer, 
2. unnecessary levels of abstraction that are decreasing testability, readability and understandability
3. unnecessary super-fancy-generic strategies, repositories  and storages that aren’t working
4. Too complex caching
5. Too much time spend on repeatable tasks like mappers
6. Too complex fragment stack and back stack (due the requirements also)


## What, why and how?

1. Kotlin
2. How can I achieve classic TDD style and is it worth it for mobile apps? 		
  * Refer here: https://martinfowler.com/articles/mocksArentStubs.html
3. How to work with autogenerated mappers (library)? Pain points were about huge boilerplatte-ish mappers implementation, and: 
  * Testing
  * Obfuscation/deobfuscation
4. GraphQL usage. It seems that querying for many nodes instead doing multiple REST calls is interesting alternative.
  * Which proxy will support working with GraphQL APIs? 
  * Is Charles enough? 
  * Will Android Studio profiler work with GraphQL?
5. Unused resources and time spending on addressing formatting comments on reviews. How static analysis can help us with that?
6. Maybe in future automation tests architecture.

### Domain
1. Testability, readability and understandability of domain as stated in the clean code manifesto
2. How in the end validation should look like. We used abstract validators with rules. I suppose concrete validators are better since every use case knows its context.
3. How composition of use cases should look like?
4. Is for simple cases (and with time constrain) worth to write use case for everything even it's just "adapter/wrapper" for repository?
It takes use case to be written, tested and then injected. 
Maybe for simple cases that aren't likely to change in future and does not contain any business logic it's better to start from repository called directly from Presenter.
Then refactor if that will change. 

### Data
1. In clean architecture we’re not using Realms biggest gains (managed objects). 
It’s not necessary to use it. 
It’s better to research alternatives and Room seems good enough. 
Since most queries are simple - Room seems to provide flexibility. 
2. How to GraphQL in data layer.
3. Check OkHttp cache constraints. Is it enough f.ex simple MVP app caching?

### App
1. Implementation of MVVM pattern with support of Android Architecture Components (ViewModel). 
Checking if we can eliminate presenters boilerplate but do not eliminate testability.
2. Check how newest Dagger API can simplify DI boilerplate-ish code. Especially around Activities/Fragments.
3. Research of RxMVP. How to test it?
4. Fragment vs Views stacks.

### Device
1. Is it worth to encapsulate framework and analytics specific classes in another module?
  * analytics
  * notifications, framework managers adapters



## Long distanced future
* encryped sharedpreferences best patterns
* encrypted DB best patterns
 
